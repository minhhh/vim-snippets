# -*- coding: utf-8 -*-

###########################################################################
#                              General Stuff                              #
###########################################################################
global !p
import re
from collections import Counter

def rst_char_len(char):
    """ 
    return len of string which fit in rst
    For instance:chinese "我" decode as only one character, 
    However, the rst interpreter needs 2 "=" instead of 1.

    :param: char needs to be count
    """
    return len(re.findall(r'[^\u4e00-\u9fff\s]', char))+len(char)

def	make_items(times, leading='+'):
    """
    make lines with leading char multitimes
    
    :param: times, how many times you need
    :param: leading, leading character
    """
    times = int(times)
    if leading == 1:
        msg = ""
        for x in xrange(1, times+1):
            msg += "%s. Item\n" % x
        return msg
    else:
        return ("%s Item\n" % leading) * times


def get_popular_code_type(path):
    """
    As function name, it will get most popular code type in given file

    :param: path, to path to rst file
    """
    with open(path) as source:
        types = re.findall(r'[:|\.\.\s]code::?\s(\w+)', source.read())
    try:
        popular_type = Counter(types).most_common()[0][0]
    except IndexError:
        popular_type = "lua" # Don't break default

    return popular_type

def complete(t, opts):
    if t:
        opts = [ m[len(t):] for m in opts if m.startswith(t) ]
    if len(opts) == 1:
        return opts[0]
    return "({0})".format("|".join(opts))

endglobal

snippet part "Part" b
`!p snip.rv = rst_char_len(t[1])*'#'`
${1:Part name}
`!p snip.rv = rst_char_len(t[1])*'#'`

$0
endsnippet

snippet sec "Section" b
${1:Section name}
`!p snip.rv = rst_char_len(t[1])*'='`

$0
endsnippet

snippet ssec "Subsection" b
${1:Section name}
`!p snip.rv = rst_char_len(t[1])*'-'`

$0
endsnippet

snippet sssec "Subsubsection" b
${1:Section name}
`!p snip.rv = rst_char_len(t[1])*'^'`

$0
endsnippet

snippet chap "Chapter" b
`!p snip.rv = rst_char_len(t[1])*'*'`
${1:Chapter name}
`!p snip.rv = rst_char_len(t[1])*'*'`

$0
endsnippet

snippet para "Paragraph" b
${1:Paragraph name}
`!p snip.rv = rst_char_len(t[1])*'"'`

$0
endsnippet

snippet em "Emphasize string" i
*${1:${VISUAL:Em}}* $0
endsnippet

# the CJK characters doesn't had space to sperate them, like "我强调"
# should be "我\ *强调*\ "
# Therefor we need special snippet
snippet ec "Emphasize string (CJK)" w
\ *${1:${VISUAL:Em}}*\ $0
endsnippet

snippet st "Strong string" i
**${1:${VISUAL:Strong}}** $0
endsnippet

snippet sc "Strong string (CJK)" w
\ **${1:${VISUAL:Strong}}**\ $0
endsnippet

snippet "li(st)? (?P<num>\d+)" "List" br
$0
`!p
snip.rv = make_items(match.groupdict()['num'])
`
endsnippet

# usage: ol 3<tab>
snippet "ol(st)? (?P<num>\d+)" "Order List" br
$0
`!p
snip.rv = make_items(match.groupdict()['num'], 1)
`
endsnippet
###########################################################################
#                         More Specialized Stuff.                         #
###########################################################################
snippet cb "Code Block" b
.. code-block:: ${1:`!p snip.rv = get_popular_code_type(path)`}

   ${2:code}

$0
endsnippet

snippet img "Image Block" b
.. |${2:alias}| image:: ${1:img}
endsnippet

snippet fig "Figure Block" b
.. figure:: ${1:img}
    :alt: ${2:alter text}
    
    ${3}

$0
endsnippet

snippet cont "Content Block" b
.. contents:: ${1:Contents Title}

$0
endsnippet

#http://docutils.sourceforge.net/docs/ref/rst/directives.html#specific-admonitions
snippet sa "Specific Admonitions" b
.. $1`!p snip.rv =complete(t[1], ["attention", "caution", "danger", 
                                  "error", "hint", "important", "note", 
                                  "tip", "warning"])`::
    
    ${2:Content}

$0
endsnippet

############
#  Sphinx  #
############

snippet sid "SideBar" b
.. sidebar:: ${1:SideBar Title}

    ${2:SideBar Content}
endsnippet
# vim:ft=snippets:
